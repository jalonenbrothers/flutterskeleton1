# Code Quality Guidelines - File Length and Conciseness

## Overview
This document provides guidelines for keeping code files concise and maintainable throughout the Flutter Skeleton App project.

## File Length Guidelines

### Maximum File Lengths
- **Hard maximum**: 600 lines (only for justified cases)
- **Soft maximum**: 400 lines (trigger for refactoring consideration)
- **Recommended**: 200-300 lines per file
- **Ideal**: 150-250 lines for most files

### Exceptions (Justified Long Files)
These file types may exceed 400 lines when necessary:

1. **Complete theme configuration** (e.g., `app_theme.dart`)
   - May reach ~500-600 lines when defining comprehensive light/dark themes
   - Acceptable if well-organized with clear section comments

2. **Generated files** (`.g.dart`, `.freezed.dart`)
   - Auto-generated by build_runner
   - Do not manually edit or split

3. **Comprehensive test files**
   - Integration tests with multiple scenarios
   - May reach 500+ lines when testing complex flows

4. **API endpoint definitions**
   - When defining 50+ endpoints in one service
   - Consider splitting by domain when exceeding 400 lines

### When to Split Files

**Immediate split required when:**
- File exceeds 600 lines
- Single responsibility principle violated
- Multiple unrelated concerns in one file
- Difficulty navigating or understanding code

**Consider splitting when:**
- File approaches 400 lines
- Adding new features would push beyond 500 lines
- Code review reveals confusion about organization
- Multiple developers editing same file frequently

## Strategies for Keeping Files Concise

### 1. Extract Methods
**Before** (80-line function):
```dart
Widget build(BuildContext context) {
  // 80 lines of widget building
}
```

**After** (well-organized):
```dart
Widget build(BuildContext context) {
  return Scaffold(
    appBar: _buildAppBar(),
    body: _buildBody(),
    bottomSheet: _buildBottomSheet(),
  );
}

Widget _buildAppBar() { /* 15 lines */ }
Widget _buildBody() { /* 30 lines */ }
Widget _buildBottomSheet() { /* 20 lines */ }
```

### 2. Widget Extraction
**Structure for complex screens:**
```
feature/
  presentation/
    screens/
      complex_screen.dart           (150 lines - main screen)
      complex_screen_widgets.dart   (200 lines - extracted widgets)
      widgets/
        screen_header.dart          (80 lines)
        screen_content.dart         (120 lines)
        screen_footer.dart          (60 lines)
```

### 3. Separate State Management
```
feature/
  presentation/
    providers/
      screen_state.dart        (100 lines - state class)
      screen_provider.dart     (80 lines - riverpod provider)
      screen_notifier.dart     (120 lines - business logic)
    screens/
      screen.dart             (150 lines - UI only)
```

### 4. Use Extensions
**Before** (bloated utility class):
```dart
class StringUtils {
  static String capitalize(String text) { }
  static bool isEmail(String text) { }
  static String truncate(String text, int length) { }
  // 20+ utility methods...
}
```

**After** (concise extension):
```dart
// lib/core/extensions/string_extension.dart (60 lines)
extension StringX on String {
  String get capitalized { }
  bool get isEmail { }
  String truncate(int length) { }
}
```

### 5. Create Sub-modules
**Before** (900-line service):
```dart
// api_service.dart (900 lines)
class ApiService {
  // Auth endpoints (150 lines)
  // User endpoints (200 lines)
  // Product endpoints (250 lines)
  // Order endpoints (300 lines)
}
```

**After** (organized modules):
```
services/
  api/
    api_service.dart           (100 lines - base client)
    auth_api.dart             (120 lines)
    user_api.dart             (150 lines)
    product_api.dart          (180 lines)
    order_api.dart            (220 lines)
```

### 6. Composition Over Inheritance
**Before** (large base class):
```dart
abstract class BaseScreen extends StatefulWidget {
  // 300 lines of shared logic
}
```

**After** (composed behavior):
```dart
// core/mixins/
mixin LoadingStateMixin { /* 60 lines */ }
mixin ErrorHandlingMixin { /* 80 lines */ }
mixin ValidationMixin { /* 70 lines */ }

// feature screen uses what it needs
class MyScreen extends ConsumerWidget 
    with LoadingStateMixin, ErrorHandlingMixin {
  // 150 lines
}
```

## File Organization Examples

### ✅ Good: Focused Files
```
auth/
  presentation/
    providers/
      auth_state.dart              (80 lines)
      auth_provider.dart           (100 lines)
    screens/
      login_screen.dart            (180 lines)
      register_screen.dart         (200 lines)
    widgets/
      auth_text_field.dart         (60 lines)
      password_field.dart          (80 lines)
      social_login_button.dart     (50 lines)
```
**Total**: 750 lines across 7 files (avg: 107 lines/file)

### ❌ Bad: Monolithic File
```
auth/
  presentation/
    screens/
      auth_screen.dart             (850 lines)
      # Contains login, register, state, widgets all in one
```

## Measuring and Monitoring

### During Development
```bash
# Check file lines before committing
find lib -name "*.dart" -exec wc -l {} + | sort -n | tail -20

# VS Code: Use line count in status bar
# Aim to keep current file under 400 lines
```

### Code Review Checklist
- [ ] No files exceed 600 lines (hard limit)
- [ ] Files over 400 lines have justification comment
- [ ] Complex files have clear section organization
- [ ] Single responsibility principle maintained
- [ ] Related files grouped logically

## Benefits of Concise Files

1. **Easier Code Review**
   - Reviewers can understand file purpose quickly
   - Less scrolling, better focus

2. **Better Testing**
   - Smaller units = easier to test
   - Clear dependencies

3. **Improved Maintainability**
   - Quick to locate specific functionality
   - Easier to refactor

4. **Reduced Merge Conflicts**
   - Smaller files = less overlap
   - Team can work in parallel

5. **Better Performance**
   - IDE indexing faster
   - Quicker hot reload

6. **Clearer Architecture**
   - Single responsibility evident
   - Dependencies explicit

## Summary

**Remember**: 
- **Target**: 200-300 lines per file
- **Soft limit**: 400 lines (consider splitting)
- **Hard limit**: 600 lines (must split)
- **Exceptions**: Theme files, generated code, comprehensive tests

**When in doubt**: Extract, don't accumulate!

---

*Last Updated: January 3, 2026*
